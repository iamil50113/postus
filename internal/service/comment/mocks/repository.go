// Code generated by MockGen. DO NOT EDIT.
// Source: comment.go

// Package gomocks is a generated GoMock package.
package gomocks

import (
	context "context"
	loader "postus/internal/controller/graphql/loader/loader"
	model "postus/internal/domain/model"
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
)

// MockCommentProvider is a mock of CommentProvider interface.
type MockCommentProvider struct {
	ctrl     *gomock.Controller
	recorder *MockCommentProviderMockRecorder
}

// MockCommentProviderMockRecorder is the mock recorder for MockCommentProvider.
type MockCommentProviderMockRecorder struct {
	mock *MockCommentProvider
}

// NewMockCommentProvider creates a new mock instance.
func NewMockCommentProvider(ctrl *gomock.Controller) *MockCommentProvider {
	mock := &MockCommentProvider{ctrl: ctrl}
	mock.recorder = &MockCommentProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommentProvider) EXPECT() *MockCommentProviderMockRecorder {
	return m.recorder
}

// ChildCommentsForParentCommentIDWithCursor mocks base method.
func (m *MockCommentProvider) ChildCommentsForParentCommentIDWithCursor(ctx context.Context, id, cursor int64, limit int) (*model.Comments, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChildCommentsForParentCommentIDWithCursor", ctx, id, cursor, limit)
	ret0, _ := ret[0].(*model.Comments)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ChildCommentsForParentCommentIDWithCursor indicates an expected call of ChildCommentsForParentCommentIDWithCursor.
func (mr *MockCommentProviderMockRecorder) ChildCommentsForParentCommentIDWithCursor(ctx, id, cursor, limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChildCommentsForParentCommentIDWithCursor", reflect.TypeOf((*MockCommentProvider)(nil).ChildCommentsForParentCommentIDWithCursor), ctx, id, cursor, limit)
}

// Comment mocks base method.
func (m *MockCommentProvider) Comment(ctx context.Context, id int64) (*model.Comment, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Comment", ctx, id)
	ret0, _ := ret[0].(*model.Comment)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Comment indicates an expected call of Comment.
func (mr *MockCommentProviderMockRecorder) Comment(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Comment", reflect.TypeOf((*MockCommentProvider)(nil).Comment), ctx, id)
}

// CommentsForPostIDWithCursor mocks base method.
func (m *MockCommentProvider) CommentsForPostIDWithCursor(ctx context.Context, id, cursor int64, limit int) (*model.Comments, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CommentsForPostIDWithCursor", ctx, id, cursor, limit)
	ret0, _ := ret[0].(*model.Comments)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CommentsForPostIDWithCursor indicates an expected call of CommentsForPostIDWithCursor.
func (mr *MockCommentProviderMockRecorder) CommentsForPostIDWithCursor(ctx, id, cursor, limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommentsForPostIDWithCursor", reflect.TypeOf((*MockCommentProvider)(nil).CommentsForPostIDWithCursor), ctx, id, cursor, limit)
}

// MultiChildExist mocks base method.
func (m *MockCommentProvider) MultiChildExist(ctx context.Context, commentIDs []*loader.ComentAndPostID, postID int64) ([]bool, []error, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MultiChildExist", ctx, commentIDs, postID)
	ret0, _ := ret[0].([]bool)
	ret1, _ := ret[1].([]error)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MultiChildExist indicates an expected call of MultiChildExist.
func (mr *MockCommentProviderMockRecorder) MultiChildExist(ctx, commentIDs, postID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MultiChildExist", reflect.TypeOf((*MockCommentProvider)(nil).MultiChildExist), ctx, commentIDs, postID)
}

// MultiFirstChildComments mocks base method.
func (m *MockCommentProvider) MultiFirstChildComments(ctx context.Context, commentIDs []int64, limit int) ([]*model.Comments, []error, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MultiFirstChildComments", ctx, commentIDs, limit)
	ret0, _ := ret[0].([]*model.Comments)
	ret1, _ := ret[1].([]error)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MultiFirstChildComments indicates an expected call of MultiFirstChildComments.
func (mr *MockCommentProviderMockRecorder) MultiFirstChildComments(ctx, commentIDs, limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MultiFirstChildComments", reflect.TypeOf((*MockCommentProvider)(nil).MultiFirstChildComments), ctx, commentIDs, limit)
}

// MockCommentSaver is a mock of CommentSaver interface.
type MockCommentSaver struct {
	ctrl     *gomock.Controller
	recorder *MockCommentSaverMockRecorder
}

// MockCommentSaverMockRecorder is the mock recorder for MockCommentSaver.
type MockCommentSaverMockRecorder struct {
	mock *MockCommentSaver
}

// NewMockCommentSaver creates a new mock instance.
func NewMockCommentSaver(ctrl *gomock.Controller) *MockCommentSaver {
	mock := &MockCommentSaver{ctrl: ctrl}
	mock.recorder = &MockCommentSaverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommentSaver) EXPECT() *MockCommentSaverMockRecorder {
	return m.recorder
}

// NewChildComment mocks base method.
func (m *MockCommentSaver) NewChildComment(ctx context.Context, uid, postID int64, body string, parentCommentID int64, publicationTime time.Time) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewChildComment", ctx, uid, postID, body, parentCommentID, publicationTime)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewChildComment indicates an expected call of NewChildComment.
func (mr *MockCommentSaverMockRecorder) NewChildComment(ctx, uid, postID, body, parentCommentID, publicationTime interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewChildComment", reflect.TypeOf((*MockCommentSaver)(nil).NewChildComment), ctx, uid, postID, body, parentCommentID, publicationTime)
}

// NewComment mocks base method.
func (m *MockCommentSaver) NewComment(ctx context.Context, uid, postID int64, body string, publicationTime time.Time) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewComment", ctx, uid, postID, body, publicationTime)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewComment indicates an expected call of NewComment.
func (mr *MockCommentSaverMockRecorder) NewComment(ctx, uid, postID, body, publicationTime interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewComment", reflect.TypeOf((*MockCommentSaver)(nil).NewComment), ctx, uid, postID, body, publicationTime)
}

// MockPostProvider is a mock of PostProvider interface.
type MockPostProvider struct {
	ctrl     *gomock.Controller
	recorder *MockPostProviderMockRecorder
}

// MockPostProviderMockRecorder is the mock recorder for MockPostProvider.
type MockPostProviderMockRecorder struct {
	mock *MockPostProvider
}

// NewMockPostProvider creates a new mock instance.
func NewMockPostProvider(ctrl *gomock.Controller) *MockPostProvider {
	mock := &MockPostProvider{ctrl: ctrl}
	mock.recorder = &MockPostProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPostProvider) EXPECT() *MockPostProviderMockRecorder {
	return m.recorder
}

// Post mocks base method.
func (m *MockPostProvider) Post(ctx context.Context, id int64) (*model.Post, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Post", ctx, id)
	ret0, _ := ret[0].(*model.Post)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Post indicates an expected call of Post.
func (mr *MockPostProviderMockRecorder) Post(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Post", reflect.TypeOf((*MockPostProvider)(nil).Post), ctx, id)
}

// MockUserProvider is a mock of UserProvider interface.
type MockUserProvider struct {
	ctrl     *gomock.Controller
	recorder *MockUserProviderMockRecorder
}

// MockUserProviderMockRecorder is the mock recorder for MockUserProvider.
type MockUserProviderMockRecorder struct {
	mock *MockUserProvider
}

// NewMockUserProvider creates a new mock instance.
func NewMockUserProvider(ctrl *gomock.Controller) *MockUserProvider {
	mock := &MockUserProvider{ctrl: ctrl}
	mock.recorder = &MockUserProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserProvider) EXPECT() *MockUserProviderMockRecorder {
	return m.recorder
}

// User mocks base method.
func (m *MockUserProvider) User(ctx context.Context, id int64) (*model.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "User", ctx, id)
	ret0, _ := ret[0].(*model.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// User indicates an expected call of User.
func (mr *MockUserProviderMockRecorder) User(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "User", reflect.TypeOf((*MockUserProvider)(nil).User), ctx, id)
}
